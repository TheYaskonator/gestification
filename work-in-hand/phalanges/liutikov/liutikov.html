<!doctype html>
<html lang=en>
<head>
<meta charset=UTF-8>
<title>Liutikov's Phalanges</title>
</head>
<body>
<script src=http://js.leapmotion.com/0.2.0/leap.min.js></script>
<script src=http://mrdoob.github.com/three.js/build/three.min.js></script>
<script src=http://mrdoob.github.com/three.js/examples/js/controls/TrackballControls.js></script>
<script src=http://mrdoob.github.com/three.js/examples/js/libs/stats.min.js></script>
<script>
// copyright (c) 2013 jaanga authors ~ MIT License
// Adapted from
// http://demo.romanliutikov.com/three/10/
// see also
// http://blog.romanliutikov.com/post/60899246643/manipulating-rigged-hand-with-leap-motion-in-three-js


	var renderer, scene, camera, controls, stats;
	var handMesh;
	
	init();
	animate();

	function init() {
		var css, info, light, geometry, material, mesh;
		
		css = document.body.appendChild( document.createElement('style') );
		css.innerHTML = 'body { font: 600 12pt monospace; margin: 0; overflow: hidden; text-align: center; }';

		info = document.body.appendChild( document.createElement( 'div' ) );
		info.style.cssText = 'position: absolute; width: 100%; ';
		info.innerHTML = info.txt = '<h1>Liutikov\'s Phalanges</h1>' +
			'Show one hand and five fingers to start ' +
			' ~ <a href=https://github.com/jaanga/gestification/tree/gh-pages/work-in-hand/phalanges/liutikov >source code</a></p>' +
		'';
		
// Three.js Basics
		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMapEnabled = true;
		document.body.appendChild( renderer.domElement );
		scene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 3000 );
		camera.position.set( 500, 250, 0 );
		controls = new THREE.TrackballControls( camera, renderer.domElement );
		controls.target.set( 0, 10, 0 );

		stats = new Stats();
		stats.domElement.style.cssText = 'position: absolute; top: 0px; zIndex: 100; ';
		document.body.appendChild( stats.domElement );	
		
//  Lights
		light = new THREE.AmbientLight( 0x333333);
		light.color.setHSL( 0.03, 0.5, 0.3 );
		scene.add( light );
		
 		light = new THREE.DirectionalLight( 0xffffff, 1 );
		light.position.set( 0, 500, 0 );
		
		light.castShadow = true;
		light.shadowMapWidth = 2048;
		light.shadowMaHeight = 2048;
		light.shadowBias = -.0001;
		light.shadowDarkness = .2;
		var d = 200;
		light.shadowCameraLeft = -d * 2;
		light.shadowCameraRight = d * 2;
		light.shadowCameraTop = d;
		light.shadowCameraBottom = -d;

		light.shadowCameraNear = 100;
		light.shadowCameraFar = 600;
//		light.shadowCameraVisible = true;
		scene.add( light );		
	
// Ground plane
		geometry = new THREE.CubeGeometry( 300, 10, 600 );
		material = new THREE.MeshBasicMaterial( {color: Math.random() * 0xffffff } );
		mesh = new THREE.Mesh( geometry, material );
		mesh.position.set( 0, -100, 0 );
		mesh.castShadow = true;
		mesh.receiveShadow = true;
		scene.add( mesh );		

// Hand mesh		
		var loader = new THREE.JSONLoader();
		loader.load( 'hand_rig.js', function ( geometry ) {
			material = new THREE.MeshLambertMaterial( { skinning: true });
			handMesh = new THREE.SkinnedMesh( geometry, material );
			handMesh.scale.set( 10, 10, 10);
			handMesh.castShadow = true;
			handMesh.receiveShadow = true;
			scene.add( handMesh );
		});
	}
	
	Leap.loop(function (frame) {
		if (frame.hands.length > 0) {
			var hand = frame.hands[0];
			handMesh.position.set( -hand.stabilizedPalmPosition[2], hand.stabilizedPalmPosition[1], hand.stabilizedPalmPosition[0] );

			var direction = new THREE.Vector3( hand.direction[0], hand.direction[1], hand.direction[ 2 ] );
			handMesh.lookAt( direction.add( handMesh.position ) );		
		
			var roll = Math.atan2( hand.palmNormal[0], hand.palmNormal[1] );
			handMesh.rotation.x = roll;   	
		
			if ( frame.pointables.length === 5 ) {
				updateFinger( frame, 3, 3 );
				updateFinger( frame, 7, 1 );
				updateFinger( frame, 11, 0 );
				updateFinger( frame, 15, 2 );
				updateFinger( frame, 19, 4, true );
			}
		}
	}); 

	function updateFinger (frame, boneNum, fingerNum, isThumb) {
		var dir = frame.pointables[fingerNum].direction;
// Theo: I am not sure what the following two lines do, but I think they prevents fingers from moving too far inappropriately		
		var dirY = - ( dir[ 0 ] >= 0.1 ) ? 0.1 : dir[ 0 ];
		var dirZ = ( dir[ 1 ] >= 0.1 ) ? 0.1 : dir[ 1 ];	
			
		if ( !isThumb ) {	
			handMesh.bones[ boneNum++ ].rotation.set( 0, -dirY, -dirZ );	
			handMesh.bones[ boneNum++ ].rotation.set( 0, 0, -dirZ );
			handMesh.bones[ boneNum ].rotation.set.z = -dir[ 2 ];
			handMesh.bones[ boneNum ].rotation.set.y = -dir[ 1 ];
			handMesh.bones[ boneNum ].rotation.set.x = -dir[ 0 ];				
		} else {
			handMesh.bones[ boneNum++ ].rotation.set( 0, -dir[ 0 ], -dir[ 1]);
			handMesh.bones[ boneNum ].rotation.set.z = dir[ 2 ];
			handMesh.bones[ boneNum ].rotation.set.y = dir[ 1 ];
			handMesh.bones[ boneNum ].rotation.set.x = dir[ 0 ];
			
		}

	}
	
	function animate() {
		requestAnimationFrame( animate );
		controls.update();
		renderer.render( scene, camera );
		stats.update();
	}
</script>
</body>
</html>